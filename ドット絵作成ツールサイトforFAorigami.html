<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¨ ãƒ‰ãƒƒãƒˆçµµä½œæˆãƒ„ãƒ¼ãƒ«</title>
    <style>
        /* åŸºæœ¬è¨­å®šã¨ãƒªã‚»ãƒƒãƒˆ */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            gap: 20px;
            position: relative; 
        }

        /* è¦ç´„ãƒªãƒ³ã‚¯ */
        #terms-link {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: #e0e4e7;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        #terms-link a {
            text-decoration: none;
            color: #555;
        }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠ (è¦‹ãŸç›®ã®æ‹¡å¤§ãƒ»ç¸®å°ç”¨) */
        #canvas-container {
            position: absolute;
            top: 20px; 
            left: 20px; 
            
            transform-origin: top left;
            transition: transform 0.3s ease-out;
            border: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            overflow: hidden; 
            z-index: 10; 
            pointer-events: auto;
        }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã®å ´æ‰€ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ */
        #canvas-placeholder {
            width: 400px; 
            height: 400px;
            pointer-events: none; 
            margin-right: 20px; 
        }
        
        #canvas {
            border: 2px solid #333;
            background-color: white;
            cursor: crosshair;
            border-radius: 5px;
            display: block; 
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ã®ã‚³ãƒ³ãƒ†ãƒŠ */
        .controls-container {
            width: 680px; 
            padding: 15px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 20; 
        }
        
        /* 2æ®µçµ„ã®ã‚³ãƒ³ãƒ†ãƒŠ */
        #control-columns {
            display: flex;
            gap: 20px;
        }
        
        .column-left, .column-right {
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex: 1; 
        }

        /* ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚ŒãŸã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        .control-group {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .control-group h3 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        /* ãƒœã‚¿ãƒ³ã®å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            font-weight: 600;
        }
        button:hover {
            opacity: 0.9;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* ãƒ—ãƒ©ã‚¤ãƒãƒªãƒœã‚¿ãƒ³ */
        #changeSize, #download {
            background-color: #007bff;
            color: white;
            margin-top: 10px;
        }

        /* ã‚»ã‚«ãƒ³ãƒ€ãƒªãƒœã‚¿ãƒ³ */
        #setColor, #saveColor, #eraser {
            background-color: #6c757d;
            color: white;
        }

        /* å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */
        input[type="number"], input[type="text"], select {
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 60px;
            margin-right: 5px;
            box-sizing: border-box;
        }
        #filename {
            width: 120px;
        }
        #imageSize {
            width: 80px;
        }
        #brushSizeSelect, #canvasZoomSelect {
            width: 100px;
            margin-left: 10px;
        }

        /* ã‚µã‚¤ã‚ºã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        #size-control p {
            margin-top: 5px;
            font-size: 0.75em;
            color: #999;
        }
        
        /* æç”»ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        #drawing-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .tool-options {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        /* ãƒ‘ãƒ¬ãƒƒãƒˆ */
        #palette {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .color {
            width: 30px;
            height: 30px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 3px;
            transition: transform 0.1s, border-color 0.2s;
        }
        .color.selected {
            border-color: #007bff;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
        }

        /* ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼å…¥åŠ› */
        #colorInput {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #colorInput .rgb-inputs {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 5px;
        }
        #colorInput label {
            font-size: 0.9em;
        }

        /* ä¿å­˜æ¸ˆã¿ã‚«ãƒ©ãƒ¼ */
        #savedColors {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding-top: 5px;
            min-height: 45px;
        }
        #savedColors button {
            width: 35px;
            height: 35px;
            padding: 0;
            border: 2px solid #333;
            border-radius: 3px;
        }

        /* æ¶ˆã—ã‚´ãƒ ãƒœã‚¿ãƒ³ */
        #eraser.selected {
            background-color: #dc3545;
            border: 2px solid #a71d2a;
        }

        /* ä¸€æ™‚çš„ãªã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼è¡¨ç¤º */
        .temp-color {
            background-color: #e9ecef;
            color: #333;
            font-weight: 600;
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #ced4da;
            margin-top: 5px;
        }

        .temp-color-box {
            display: inline-block;
            width: 20px;
            height: 20px;
            vertical-align: middle;
            margin-right: 5px;
            border: 1px solid #333;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ */
        .format-radio-group {
            margin-top: 5px;
        }
        .format-radio-group label {
            margin-right: 15px;
        }
    </style>
</head>
<body>
    <div id="terms-link">
        <a href="https://faorigami.github.io/FAorigami_site/ãƒ‰ãƒƒãƒˆçµµä½œæˆãƒ„ãƒ¼ãƒ«ã‚µã‚¤ãƒˆforFAorigamiã®åˆ©ç”¨è¦ç´„ã¨æ³¨æ„äº‹é ….html" target="_blank">åˆ©ç”¨è¦ç´„ã¨æ³¨æ„äº‹é …</a>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="400" height="400"></canvas>
    </div>
    
    <div id="canvas-placeholder"></div>

    <div class="controls-container">
        <div id="control-columns">
            <div class="column-left">
                <div id="size-control" class="control-group">
                    <h3>ã‚­ãƒ£ãƒ³ãƒã‚¹è¨­å®š</h3>
                    <div>
                        <label for="gridPixelSize">ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º (ç¸¦æ¨ª):</label>
                        <input type="number" id="gridPixelSize" value="16" min="8" max="64" step="8">
                        <button id="changeSize">ã‚µã‚¤ã‚ºå¤‰æ›´ (ãƒªã‚»ãƒƒãƒˆ)</button>
                        <p>â€»å¤‰æ›´ã™ã‚‹ã¨æç”»å†…å®¹ã¯ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ (8ã€œ64ã®ç¯„å›²ã§æ¨å¥¨)ã€‚</p>
                    </div>

                    <div class="tool-options">
                        <label for="canvasZoomSelect">è¡¨ç¤ºå€ç‡ (è¦‹ãŸç›®):</label>
                        <select id="canvasZoomSelect">
                            <option value="0.5">50%</option>
                            <option value="1.0" selected>100%</option>
                            <option value="1.5">150%</option>
                            <option value="2.0">200%</option>
                        </select>
                    </div>
                </div>

                <div id="drawing-controls" class="control-group">
                    <h3>ğŸ–Œï¸ æç”»ãƒ„ãƒ¼ãƒ«</h3>
                    <button id="eraser">æ¶ˆã—ã‚´ãƒ </button>
                    <div class="tool-options">
                        <label for="brushSizeSelect">ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚º (ã‚»ãƒ«):</label>
                        <select id="brushSizeSelect">
                            <option value="1">1x1</option>
                            <option value="2">2x2</option>
                            <option value="3">3x3</option>
                            <option value="4">4x4</option>
                        </select>
                    </div>
                </div>

                <div class="control-group">
                    <h3>ğŸ¨ åŸºæœ¬ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ</h3>
                    <div id="palette">
                        <div class="color selected" style="background-color: black;" data-color="black"></div>
                        <div class="color" style="background-color: red;" data-color="red"></div>
                        <div class="color" style="background-color: blue;" data-color="blue"></div>
                        <div class="color" style="background-color: green;" data-color="green"></div>
                        <div class="color" style="background-color: yellow;" data-color="yellow"></div>
                        <div class="color" style="background-color: white;" data-color="white"></div>
                    </div>
                </div>
            </div> <div class="column-right">
                <div id="colorInput" class="control-group">
                    <h3>ğŸŒˆ ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ (RGB)</h3>
                    <div class="rgb-inputs">
                        <label for="red">R:</label><input type="number" id="red" value="0" min="0" max="255">
                        <label for="green">G:</label><input type="number" id="green" value="0" min="0" max="255">
                        <label for="blue">B:</label><input type="number" id="blue" value="0" min="0" max="255">
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                        <button id="setColor">è‰²ã‚’è¨­å®š</button>
                        <button id="saveColor">è‰²ã‚’ä¿å­˜</button>
                    </div>
                    </div>

                <div class="control-group">
                    <h3>ğŸ’¾ ä¿å­˜æ¸ˆã¿ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼</h3>
                    <div id="savedColors">
                        </div>
                </div>

                <div id="controls" class="control-group">
                    <h3>â¬‡ï¸ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</h3>
                    <div>
                        <label for="filename">ãƒ•ã‚¡ã‚¤ãƒ«å:</label>
                        <input type="text" id="filename" value="pixel_art">
                    </div>

                    <div style="margin-top: 10px;">
                        <label for="imageSize">ç”»åƒã‚µã‚¤ã‚º:</label>
                        <input type="number" id="imageSize" value="16" min="1" max="1024">
                    </div>

                    <div class="format-radio-group">
                        <label>ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼:</label>
                        <input type="radio" id="pngFormat" name="fileFormat" value="png" checked>
                        <label for="pngFormat">PNG (æ¨å¥¨)</label>
                        <input type="radio" id="bmpFormat" name="fileFormat" value="bmp">
                        <label for="bmpFormat">BMP</label>
                    </div>
                    
                    <button id="download">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                </div>
            </div> 
        </div> 
    </div> 

    <script>
        // --- è¦ç´ ã®å–å¾— ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container'); 
        const canvasPlaceholder = document.getElementById('canvas-placeholder'); 
        const canvasZoomSelect = document.getElementById('canvasZoomSelect'); 
        const palette = document.getElementById('palette');
        const eraserButton = document.getElementById('eraser');
        const downloadButton = document.getElementById('download');
        const redInput = document.getElementById('red');
        const greenInput = document.getElementById('green');
        const blueInput = document.getElementById('blue');
        const setColorButton = document.getElementById('setColor');
        const saveColorButton = document.getElementById('saveColor');
        const savedColorsDiv = document.getElementById('savedColors');
        const filenameInput = document.getElementById('filename');
        const imageSizeInput = document.getElementById('imageSize');
        const pngFormatRadio = document.getElementById('pngFormat');
        const bmpFormatRadio = document.getElementById('bmpFormat');
        const gridPixelSizeInput = document.getElementById('gridPixelSize');
        const changeSizeButton = document.getElementById('changeSize');
        const brushSizeSelect = document.getElementById('brushSizeSelect');

        // --- å®šæ•°ã¨å¤‰æ•° ---
        const fixedCanvasSize = 400; 
        canvas.width = fixedCanvasSize;
        canvas.height = fixedCanvasSize;

        let gridSize;
        let cellSize;
        let currentColor = 'black';
        let isErasing = false;
        let isDrawing = false;
        let shouldDrawGrid = true;
        let brushSize = 1;
        let currentZoom = 1.0; 

        const COLOR_NONE = 0;
        const COLOR_BLACK = 1;
        const COLOR_RED = 2;
        const COLOR_BLUE = 3;
        const COLOR_GREEN = 4;
        const COLOR_YELLOW = 5;
        const COLOR_WHITE = 6;
        let customColorIndex = 7;
        let savedColors = {};

        const paletteColors = {
            'black': COLOR_BLACK, 'red': COLOR_RED, 'blue': COLOR_BLUE,
            'green': COLOR_GREEN, 'yellow': COLOR_YELLOW, 'white': COLOR_WHITE
        };

        var pixelData = [];

        // --- åŸºæœ¬æ©Ÿèƒ½ ---

        function initializeGrid(newSize) {
            gridSize = newSize;
            cellSize = fixedCanvasSize / gridSize;
            
            pixelData = [];
            for (let i = 0; i < gridSize; i++) {
                pixelData[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    pixelData[i][j] = COLOR_NONE;
                }
            }
            imageSizeInput.value = newSize;
            drawCanvas();
        }

        function drawGrid() {
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
        }
        
        function getColorFromCode(pixelValue) {
            if (pixelValue === COLOR_NONE) return 'transparent';
            if (pixelValue === COLOR_BLACK) return 'black';
            if (pixelValue === COLOR_RED) return 'red';
            if (pixelValue === COLOR_BLUE) return 'blue';
            if (pixelValue === COLOR_GREEN) return 'green';
            if (pixelValue === COLOR_YELLOW) return 'yellow';
            if (pixelValue === COLOR_WHITE) return 'white';
            return savedColors[pixelValue] || 'transparent';
        }


        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    let color = getColorFromCode(pixelData[i][j]);
                    ctx.fillStyle = color;
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }

            if (shouldDrawGrid) {
                drawGrid();
            }
        }

        initializeGrid(parseInt(gridPixelSizeInput.value));

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        
        // è¡¨ç¤ºå€ç‡å¤‰æ›´
        canvasZoomSelect.addEventListener('change', (e) => {
            currentZoom = parseFloat(e.target.value);
            
            canvasContainer.style.transform = `scale(${currentZoom})`;
            
            // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®ã‚µã‚¤ã‚ºã‚’ã€æ‹¡å¤§å¾Œã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦èª¿æ•´
            canvasPlaceholder.style.width = `${fixedCanvasSize * currentZoom}px`;
            canvasPlaceholder.style.height = `${fixedCanvasSize * currentZoom}px`;
        });

        // ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚ºå¤‰æ›´
        brushSizeSelect.addEventListener('change', (e) => {
            brushSize = parseInt(e.target.value);
        });

        // ãƒ‘ãƒ¬ãƒƒãƒˆé¸æŠ
        palette.addEventListener('click', (e) => {
            if (e.target.classList.contains('color')) {
                currentColor = e.target.getAttribute('data-color');
                isErasing = false;
                
                palette.querySelectorAll('.color').forEach(c => c.classList.remove('selected'));
                e.target.classList.add('selected');
                eraserButton.classList.remove('selected');
                savedColorsDiv.querySelectorAll('button').forEach(b => b.removeAttribute('data-selected'));
                
                const existingTemp = document.querySelector('.temp-color');
                if (existingTemp) existingTemp.remove();
            }
        });

        // ä¿å­˜æ¸ˆã¿ã‚«ãƒ©ãƒ¼é¸æŠ
        savedColorsDiv.addEventListener('click', (e) => {
             if (e.target.tagName === 'BUTTON' && e.target.dataset.colorIndex) {
                 currentColor = parseInt(e.target.dataset.colorIndex);
                 isErasing = false;
                 
                 palette.querySelectorAll('.color').forEach(c => c.classList.remove('selected'));
                 eraserButton.classList.remove('selected');
                 savedColorsDiv.querySelectorAll('button').forEach(b => b.removeAttribute('data-selected'));
                 e.target.setAttribute('data-selected', 'true');
                 
                 const existingTemp = document.querySelector('.temp-color');
                 if (existingTemp) existingTemp.remove();
             }
        });

        // æ¶ˆã—ã‚´ãƒ 
        eraserButton.addEventListener('click', () => {
            isErasing = true;
            eraserButton.classList.add('selected');
            palette.querySelectorAll('.color').forEach(c => c.classList.remove('selected'));
            savedColorsDiv.querySelectorAll('button').forEach(b => b.removeAttribute('data-selected'));
            
            const existingTemp = document.querySelector('.temp-color');
            if (existingTemp) existingTemp.remove();
        });

        // æç”»å‡¦ç† (åº§æ¨™è¨ˆç®—ã¯å‰å›ä¿®æ­£æ¸ˆã¿)
        function paint(e) {
            const rect = canvas.getBoundingClientRect();
            
            // ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨å‰ã®ã‚­ãƒ£ãƒ³ãƒã‚¹å†…éƒ¨åº§æ¨™ç³»(400x400)ã§ã®æ­£ç¢ºãªåº§æ¨™ã‚’å¾—ã‚‹ã€‚
            const xOffset = (e.clientX - rect.left) / currentZoom;
            const yOffset = (e.clientY - rect.top) / currentZoom;

            const x = Math.floor(xOffset / cellSize);
            const y = Math.floor(yOffset / cellSize);
            
            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;

            let colorCode;
            if (isErasing) {
                colorCode = COLOR_NONE;
            } else {
                if (paletteColors[currentColor]) {
                    colorCode = paletteColors[currentColor];
                } else if (typeof currentColor === 'number' && savedColors[currentColor]) {
                    colorCode = currentColor;
                } else if (typeof currentColor === 'string' && currentColor.startsWith('rgb')) {
                    alert('ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã¯æœªä¿å­˜ã§ã™ã€‚å¡—ã‚‹ã«ã¯ã€Œè‰²ã‚’ä¿å­˜ã€ã‚’æŠ¼ã—ã¦ä¿å­˜æ¸ˆã¿ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„ã€‚');
                    return;
                } else {
                    return;
                }
            }
            
            const halfBrush = Math.floor(brushSize / 2);
            let updated = false;

            for (let i = 0; i < brushSize; i++) {
                for (let j = 0; j < brushSize; j++) {
                    const drawX = x + i - halfBrush;
                    const drawY = y + j - halfBrush;

                    if (drawX >= 0 && drawX < gridSize && drawY >= 0 && drawY < gridSize) {
                        if (pixelData[drawX][drawY] !== colorCode) {
                            pixelData[drawX][drawY] = colorCode;
                            updated = true;
                        }
                    }
                }
            }
            
            if (updated) {
                 drawCanvas();
            }
        }

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            paint(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                paint(e);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseout', () => {
            isDrawing = false;
        });
        
        // æç”»ã‚µã‚¤ã‚ºå¤‰æ›´
        changeSizeButton.addEventListener('click', () => {
            const newSize = parseInt(gridPixelSizeInput.value);
            if (newSize >= 8 && newSize <= 64 && newSize % 8 === 0) {
                if (confirm(`ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã‚’ ${newSize}x${newSize} ã«å¤‰æ›´ã™ã‚‹ã¨ã€ç¾åœ¨ã®æç”»å†…å®¹ã¯å…¨ã¦æ¶ˆå»ã•ã‚Œã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`)) {
                    initializeGrid(newSize);
                    alert(`${newSize}x${newSize}ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚`);
                }
            } else {
                alert('ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã¯8ã‹ã‚‰64ã®ç¯„å›²ã§ã€8ã®å€æ•°ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
                gridPixelSizeInput.value = gridSize;
            }
        });

        // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç† 
        downloadButton.addEventListener('click', () => {
            shouldDrawGrid = false;
            drawCanvas();

            const downloadSize = parseInt(imageSizeInput.value);
            
            if (downloadSize < 1 || downloadSize > 1024 || isNaN(downloadSize)) {
                alert('ç”»åƒã‚µã‚¤ã‚ºã¯1ã‹ã‚‰1024ã®ç¯„å›²ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
                shouldDrawGrid = true;
                drawCanvas();
                return;
            }

            const downloadCanvas = document.createElement('canvas');
            downloadCanvas.width = downloadSize;
            downloadCanvas.height = downloadSize;
            const downloadCtx = downloadCanvas.getContext('2d');
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    let color = getColorFromCode(pixelData[i][j]);
                    if (color === 'transparent') {
                        color = 'rgba(0,0,0,0)';
                    }
                    
                    const x = Math.floor(i * downloadSize / gridSize);
                    const y = Math.floor(j * downloadSize / gridSize);
                    const width = Math.ceil((i + 1) * downloadSize / gridSize) - x;
                    const height = Math.ceil((j + 1) * downloadSize / gridSize) - y;
                    
                    downloadCtx.fillStyle = color;
                    downloadCtx.fillRect(x, y, width, height);
                }
            }

            let selectedFormat = pngFormatRadio.checked ? 'image/png' : 'image/bmp';
            let fileExtension = pngFormatRadio.checked ? '.png' : '.bmp';

            const filename = (filenameInput.value.trim() === '' ? 'pixel_art' : filenameInput.value.trim()) + fileExtension;
            const link = document.createElement('a');
            
            if (selectedFormat === 'image/bmp') {
                 downloadCtx.globalCompositeOperation = 'destination-over';
                 downloadCtx.fillStyle = 'white';
                 downloadCtx.fillRect(0, 0, downloadSize, downloadSize);
                 alert('BMPå½¢å¼ã¯ä¸€éƒ¨ãƒ–ãƒ©ã‚¦ã‚¶ã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚PNGå½¢å¼ã‚’æ¨å¥¨ã—ã¾ã™ã€‚');
            }
            
            link.href = downloadCanvas.toDataURL(selectedFormat);
            link.download = filename;
            link.click();

            shouldDrawGrid = true;
            drawCanvas();
        });

        // ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼è¨­å®šã¨ä¿å­˜ 
        function updateTempColorDisplay(colorString) {
            const existingTemp = document.querySelector('.temp-color');
            if (existingTemp) existingTemp.remove();
            
            const tempDiv = document.createElement('div');
            tempDiv.classList.add('temp-color');
            const parent = setColorButton.closest('.control-group');
            
            tempDiv.innerHTML = `é¸æŠä¸­: <span class="temp-color-box" style="background-color: ${colorString};"></span> ${colorString}`;
            
            parent.appendChild(tempDiv);
        }
        
        setColorButton.addEventListener('click', () => {
            const red = parseInt(redInput.value);
            const green = parseInt(greenInput.value);
            const blue = parseInt(blueInput.value);

            if (red >= 0 && red <= 255 && green >= 0 && green <= 255 && blue >= 0 && blue <= 255) {
                const colorString = `rgb(${red}, ${green}, ${blue})`;
                currentColor = colorString;
                
                isErasing = false;
                palette.querySelectorAll('.color').forEach(c => c.classList.remove('selected'));
                eraserButton.classList.remove('selected');
                savedColorsDiv.querySelectorAll('button').forEach(b => b.removeAttribute('data-selected'));
                
                updateTempColorDisplay(colorString);
            } else {
                alert('èµ¤ã€ç·‘ã€é’ã®å€¤ã¯0ã‹ã‚‰255ã®ç¯„å›²ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
            }
        });

        saveColorButton.addEventListener('click', () => {
            const red = parseInt(redInput.value);
            const green = parseInt(greenInput.value);
            const blue = parseInt(blueInput.value);

            if (red >= 0 && red <= 255 && green >= 0 && green <= 255 && blue >= 0 && blue <= 255) {
                const colorString = `rgb(${red}, ${green}, ${blue})`;
                
                let existingIndex = Object.keys(savedColors).find(key => savedColors[key] === colorString);

                if (existingIndex) {
                    existingIndex = parseInt(existingIndex);
                    currentColor = existingIndex;
                    alert(`ã“ã®ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã¯æ—¢ã«ä¿å­˜æ¸ˆã¿ã§ã™ã€‚`);
                } else {
                    currentColor = customColorIndex;
                    savedColors[customColorIndex] = colorString;
                    
                    const button = document.createElement('button');
                    button.style.backgroundColor = colorString;
                    button.dataset.colorIndex = customColorIndex;
                    button.setAttribute('data-selected', 'true');
                    savedColorsDiv.appendChild(button);
                    customColorIndex++;
                    alert(`ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã€Œ${colorString}ã€ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚`);

                    existingIndex = currentColor;
                }

                isErasing = false;
                palette.querySelectorAll('.color').forEach(c => c.classList.remove('selected'));
                eraserButton.classList.remove('selected');
                
                savedColorsDiv.querySelectorAll('button').forEach(b => {
                    b.removeAttribute('data-selected');
                    if (parseInt(b.dataset.colorIndex) === existingIndex) {
                        b.setAttribute('data-selected', 'true');
                    }
                });
                
                const existingTemp = document.querySelector('.temp-color');
                if (existingTemp) existingTemp.remove();
                
            } else {
                alert('èµ¤ã€ç·‘ã€é’ã®å€¤ã¯0ã‹ã‚‰255ã®ç¯„å›²ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
            }
        });

        // åˆå›å®Ÿè¡Œæ™‚ã«ã‚­ãƒ£ãƒ³ãƒã‚¹è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’æ­£ã—ãè¨­å®š
        document.addEventListener('DOMContentLoaded', () => {
            // åˆæœŸçŠ¶æ…‹ã® 100% ã®ã‚µã‚¤ã‚ºã‚’ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã«é©ç”¨
            canvasPlaceholder.style.width = `${fixedCanvasSize * currentZoom}px`;
            canvasPlaceholder.style.height = `${fixedCanvasSize * currentZoom}px`;
        });
    </script>
</body>
</html>
