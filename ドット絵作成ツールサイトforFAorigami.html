<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé® Êã°ÂºµÁâà„Éâ„ÉÉ„ÉàÁµµ„Ç®„Éá„Ç£„Çø„Éº</title>
    <style>
        /* ÂÖ®‰Ωì„É¨„Ç§„Ç¢„Ç¶„Éà */
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: row;
            height: 100vh;
            margin: 0;
            background-color: #1e272e;
            color: #d2dae2;
            overflow: hidden;
        }

        /* Âà©Áî®Ë¶èÁ¥Ñ„ÇíÂ§ß„Åç„ÅèÂº∑Ë™ø */
        .terms-header {
            background-color: #485460;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 2px solid #ef5777;
            margin-bottom: 5px;
        }
        .terms-header a {
            color: #fffa65;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1em;
            display: block;
        }
        .terms-header a:hover {
            text-decoration: underline;
            color: #ffffff;
        }

        /* „Çµ„Ç§„Éâ„Éê„Éº */
        .sidebar {
            width: 320px;
            min-width: 320px;
            background-color: #2f3640;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            border-right: 1px solid #4b4b4b;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #1e272e;
            overflow: auto;
            padding: 10px;
        }

        #canvas-container {
            transform-origin: center;
            line-height: 0;
            background-color: #fff;
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
            position: relative;
        }

        canvas { display: block; cursor: crosshair; }

        /* ÂêÑ„Ç∞„É´„Éº„ÉóË®≠ÂÆö */
        .control-group {
            background-color: #353b48;
            padding: 8px;
            border-radius: 6px;
            border-bottom: 2px solid #4b7bec;
        }
        .control-group h3 {
            margin: 0 0 5px 0;
            font-size: 0.65em;
            color: #4b7bec;
            text-transform: uppercase;
        }

        .row {
            display: flex;
            gap: 4px;
            align-items: center;
            margin-bottom: 3px;
        }

        .label-sm { font-size: 0.7em; flex: 1; }

        input[type="number"], input[type="text"], select {
            background-color: #1e272e;
            border: 1px solid #4b4b4b;
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.75em;
            width: 50px;
        }

        button {
            padding: 4px 6px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.75em;
            transition: 0.2s;
        }

        .btn-blue { background-color: #4b7bec; color: white; }
        .btn-red { background-color: #eb3b5a; color: white; }
        .btn-gray { background-color: #718093; color: white; }
        .btn-green { background-color: #20bf6b; color: white; width: 100%; margin-top: 2px; }

        /* „ÉÑ„Éº„É´„Éú„Çø„É≥ */
        .tool-btn { 
             flex: 1; 
             background-color: #778ca3; 
             color: white; 
             display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 6px 2px;
        }
        .tool-btn.active { background-color: #eb3b5a; }
        .tool-btn select { width: 90%; margin-top: 2px; }

        /* „Éó„É™„Çª„ÉÉ„Éà„Éë„É¨„ÉÉ„Éà */
        #palette {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            margin-bottom: 5px;
        }
        .color-tile {
            aspect-ratio: 1;
            border-radius: 3px;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .color-tile.selected { border: 2px solid white; box-shadow: 0 0 4px #fff; }

        /* „Ç´„Çπ„Çø„É†„Ç´„É©„Éº„Ç®„É™„Ç¢ */
        #savedColors {
            display: grid;
            grid-template-columns: repeat(9, 1fr); 
            gap: 2px; 
            margin-top: 6px;
            width: 100%;
            background-color: #262c35;
            padding: 4px;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .saved-item {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            background-color: #3d4652;
            border-radius: 2px;
            box-sizing: border-box;
        }
        .saved-tile {
            width: 100%;
            height: 100%;
            border-radius: 2px;
            cursor: pointer;
            border: none;
            display: block;
        }
        .saved-tile.selected { 
             outline: 2px solid white; 
             outline-offset: -2px;
            z-index: 5; 
         }
        
        .del-btn {
            position: absolute;
            top: -3px;
            right: -3px;
            width: 14px;
            height: 14px;
            background: #eb3b5a;
            color: white;
            font-size: 10px;
            line-height: 14px;
            text-align: center;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            border: 1px solid white;
            z-index: 10;
        }
        .saved-item:hover .del-btn { display: block; }
        
        #color-count { font-size: 0.65em; color: #4b7bec; font-weight: bold; }
        
        /* „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç≠„ÉºÊ°àÂÜÖ */
        .shortcut-info {
            font-size: 0.65em;
            color: #95afc0;
            margin-top: 5px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="terms-header">
            <a href="https://faorigami.github.io/FAorigami_site/Tool_Terms_of_Use.html" target="_blank">Âà©Áî®Ë¶èÁ¥Ñ</a>
        </div>
        <div class="terms-header">
            <a href="https://faorigami.github.io/FAorigami_site/„Éâ„ÉÉ„ÉàÁµµ‰ΩúÊàê„ÉÑ„Éº„É´„Çµ„Ç§„ÉàforFAorigami„ÅÆÊ≥®ÊÑè‰∫ãÈ†Ö.html" target="_blank">Ê≥®ÊÑè‰∫ãÈ†Ö</a>
        </div>

        <div class="control-group">
            <h3>üñ•Ô∏è Canvas & Grid</h3>
            <div class="row">
                <span class="label-sm">Ë°®Á§∫ÂπÖ:</span>
                <input type="number" id="displaySizeInput" value="600" step="50">
                <button id="applyDisplaySize" class="btn-blue">ÈÅ©Áî®</button>
            </div>
            <div class="row">
                <span class="label-sm">„Ç∞„É™„ÉÉ„Éâ:</span>
                <input type="number" id="gridPixelSize" value="32" min="4" max="256">
                <button id="resetCanvas" class="btn-red">Êñ∞Ë¶è</button>
            </div>
            <div class="row">
                <span class="label-sm">Êìç‰Ωú:</span>
                <button id="undoBtn" class="btn-gray" style="flex:1;">Undo (Ctrl+Z)</button>
            </div>
            <div class="row">
                <span class="label-sm">„Ç∫„Éº„É†:</span>
                <select id="canvasZoomSelect" style="flex:1;">
                    <option value="0.5">50%</option>
                    <option value="1.0" selected>100%</option>
                    <option value="1.5">150%</option>
                    <option value="2.0">200%</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <h3>üñåÔ∏è Tools</h3>
            <div class="row">
                <div id="penTool" class="tool-btn active">
                    <span>Á≠Ü</span>
                    <select id="penSizeSelect">
                        <option value="1">1x1</option>
                        <option value="2">2x2</option>
                        <option value="3">3x3</option>
                        <option value="4">4x4</option>
                    </select>
                </div>
                <div id="eraserTool" class="tool-btn">
                    <span>Ê∂à„Åó„Ç¥„É†</span>
                    <select id="eraserSizeSelect">
                        <option value="1">1x1</option>
                        <option value="2">2x2</option>
                        <option value="3" selected>3x3</option>
                        <option value="4">4x4</option>
                    </select>
                </div>
                <div id="pickerTool" class="tool-btn">
                    <span>„Çπ„Éù„Ç§„Éà</span>
                    <div style="font-size:0.6em; margin-top:4px;">(Alt+Click)</div>
                </div>
            </div>
            <div class="shortcut-info">
                ‚Äª Shift+„ÇØ„É™„ÉÉ„ÇØ„ÅßÁõ¥Á∑öÊèèÁîª<br>
                ‚Äª Alt+„ÇØ„É™„ÉÉ„ÇØ„Åß„Çπ„Éù„Ç§„Éà
            </div>
        </div>

        <div class="control-group">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                <h3>üé® Palette</h3>
                <div id="color-count">0 / 45</div>
            </div>
            <div id="palette">
                <div class="color-tile selected" style="background-color: black;" data-color="black"></div>
                <div class="color-tile" style="background-color: #ff0000;" data-color="#ff0000"></div>
                <div class="color-tile" style="background-color: #0000ff;" data-color="#0000ff"></div>
                <div class="color-tile" style="background-color: #00ff00;" data-color="#00ff00"></div>
                <div class="color-tile" style="background-color: #ffff00;" data-color="#ffff00"></div>
                <div class="color-tile" style="background-color: #ffffff;" data-color="#ffffff"></div>
            </div>
            <div class="row">
                <input type="number" id="red" value="0" min="0" max="255" placeholder="R">
                <input type="number" id="green" value="0" min="0" max="255" placeholder="G">
                <input type="number" id="blue" value="0" min="0" max="255" placeholder="B">
                <button id="saveColor" class="btn-blue" style="flex:1;">‰øùÂ≠ò</button>
            </div>
            <div id="savedColors"></div>
        </div>

        <div class="control-group">
            <h3>üíæ Export</h3>
            <div class="row">
                <input type="text" id="filename" value="dot_art" style="flex:1;" placeholder="Name">
                <input type="number" id="imageSize" value="128" placeholder="px">
            </div>
            <div class="row">
                <select id="formatSelect" style="width:100%;">
                    <option value="png">PNG</option>
                    <option value="bmp">BMP</option>
                    <option value="ico">ICO</option>
                </select>
            </div>
            <button id="download" class="btn-green">ÁîªÂÉè„Çí‰øùÂ≠ò</button>
        </div>
    </div>

    <div class="main-content">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');
        const displaySizeInput = document.getElementById('displaySizeInput');
        const gridPixelSizeInput = document.getElementById('gridPixelSize');
        
        const penTool = document.getElementById('penTool');
        const eraserTool = document.getElementById('eraserTool');
        const pickerTool = document.getElementById('pickerTool');
        const penSizeSelect = document.getElementById('penSizeSelect');
        const eraserSizeSelect = document.getElementById('eraserSizeSelect');

        const savedColorsDiv = document.getElementById('savedColors');
        const colorCountSpan = document.getElementById('color-count');

        let currentDisplaySize = 600; 
        let gridSize = 32;
        let cellSize;
        let currentColor = 'black';
        let isErasing = false;
        let isPicking = false;
        let isDrawing = false;
        let currentZoom = 1.0;
        
        // Áõ¥Á∑öÊèèÁîªÁî®
        let lastX = null;
        let lastY = null;
        let isShiftDown = false;

        let brushSize = 1;
        let eraserSize = 3;

        let pixelData = []; 
        let undoStack = [];
        const MAX_UNDO = 20;

        let savedColorsMap = new Map(); 
        let customColorIndex = 100;
        const MAX_COLORS = 45;

        function init() {
            currentDisplaySize = parseInt(displaySizeInput.value);
            gridSize = parseInt(gridPixelSizeInput.value);
            setupGridData(); 
            updateCanvasView();
            renderSavedColors(); 
        }

        function setupGridData() {
            pixelData = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
            undoStack = [];
        }

        function saveState() {
            undoStack.push(JSON.stringify(pixelData));
            if (undoStack.length > MAX_UNDO) undoStack.shift();
        }

        function undo() {
            if (undoStack.length > 0) {
                pixelData = JSON.parse(undoStack.pop());
                draw();
            }
        }

        function updateCanvasView() {
            canvas.width = currentDisplaySize;
            canvas.height = currentDisplaySize;
            cellSize = currentDisplaySize / gridSize;
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const val = pixelData[i][j];
                    if (val !== 0) {
                        ctx.fillStyle = getActualColor(val);
                        ctx.fillRect(i * cellSize, j * cellSize, Math.ceil(cellSize), Math.ceil(cellSize));
                    }
                }
            }
            // „Ç∞„É™„ÉÉ„ÉâÁ∑ö
            ctx.strokeStyle = "rgba(0,0,0,0.1)";
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath(); ctx.moveTo(i * cellSize, 0); ctx.lineTo(i * cellSize, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i * cellSize); ctx.lineTo(canvas.width, i * cellSize); ctx.stroke();
            }
        }

        function getActualColor(val) {
            if (typeof val === 'string') return val;
            return savedColorsMap.get(val) || "rgba(0,0,0,0)";
        }

        // „Éñ„É¨„Çº„É≥„Éè„É†„ÅÆ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíÁî®„ÅÑ„ÅüÁõ¥Á∑öË£úÂÆåÊèèÁîª
        function drawLine(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                applyPaintAt(x0, y0);
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        function applyPaintAt(x, y) {
            const color = isErasing ? 0 : currentColor;
            const currentSize = isErasing ? eraserSize : brushSize;
            const offset = Math.floor(currentSize / 2);

            for (let i = 0; i < currentSize; i++) {
                for (let j = 0; j < currentSize; j++) {
                    const tx = x + i - offset;
                    const ty = y + j - offset;
                    if (tx >= 0 && tx < gridSize && ty >= 0 && ty < gridSize) {
                        pixelData[tx][ty] = color;
                    }
                }
            }
        }

        function handlePointerAction(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor(((e.clientX - rect.left) / currentZoom) / cellSize);
            const y = Math.floor(((e.clientY - rect.top) / currentZoom) / cellSize);
            
            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;

            // „Çπ„Éù„Ç§„ÉàÊ©üËÉΩ
            if (isPicking || e.altKey) {
                const val = pixelData[x][y];
                if (val !== 0) {
                    const colorVal = getActualColor(val);
                    if (typeof val === 'number') {
                        currentColor = val;
                    } else {
                        currentColor = colorVal;
                    }
                    setTool('pen');
                    refreshColorSelection();
                }
                return;
            }

            // Áõ¥Á∑öÊèèÁîª (ShiftÊäº‰∏ãÊôÇ)
            if (e.shiftKey && lastX !== null && lastY !== null) {
                saveState();
                drawLine(lastX, lastY, x, y);
            } else {
                if (e.type === 'mousedown') saveState();
                applyPaintAt(x, y);
            }

            lastX = x;
            lastY = y;
            draw();
        }

        // --- „ÉÑ„Éº„É´Âàá„ÇäÊõø„Åà„É≠„Ç∏„ÉÉ„ÇØ ---
        function setTool(mode) {
            isErasing = (mode === 'eraser');
            isPicking = (mode === 'picker');
            
            penTool.classList.toggle('active', mode === 'pen');
            eraserTool.classList.toggle('active', mode === 'eraser');
            pickerTool.classList.toggle('active', mode === 'picker');

            if (mode === 'eraser' || mode === 'picker') {
                document.querySelectorAll('.color-tile, .saved-tile').forEach(el => el.classList.remove('selected'));
            } else {
                refreshColorSelection();
            }
        }

        penTool.addEventListener('click', (e) => { if(e.target === penSizeSelect) return; setTool('pen'); });
        eraserTool.addEventListener('click', (e) => { if(e.target === eraserSizeSelect) return; setTool('eraser'); });
        pickerTool.addEventListener('click', () => setTool('picker'));
        
        penSizeSelect.addEventListener('change', (e) => brushSize = parseInt(e.target.value));
        eraserSizeSelect.addEventListener('change', (e) => eraserSize = parseInt(e.target.value));

        // --- „Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà ---
        canvas.addEventListener('mousedown', (e) => { 
            isDrawing = true; 
            handlePointerAction(e); 
        });
        canvas.addEventListener('mousemove', (e) => { 
            if(isDrawing && !e.shiftKey) handlePointerAction(e); 
        });
        window.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') isShiftDown = true;
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') isShiftDown = false;
        });

        document.getElementById('undoBtn').addEventListener('click', undo);

        document.getElementById('applyDisplaySize').addEventListener('click', () => {
            currentDisplaySize = parseInt(displaySizeInput.value);
            updateCanvasView();
        });

        document.getElementById('canvasZoomSelect').addEventListener('change', (e) => {
            currentZoom = parseFloat(e.target.value);
            canvasContainer.style.transform = `scale(${currentZoom})`;
        });

        document.getElementById('resetCanvas').addEventListener('click', () => {
            if(confirm("ÂÖ®Ê∂àÂéª„Åó„Å¶Êñ∞„Åó„ÅÑ„Ç≠„É£„É≥„Éê„Çπ„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÅãÔºü")) {
                gridSize = parseInt(gridPixelSizeInput.value);
                setupGridData(); updateCanvasView();
            }
        });

        document.getElementById('palette').addEventListener('click', (e) => {
            if(e.target.classList.contains('color-tile')) {
                selectColor(e.target.dataset.color);
            }
        });

        function selectColor(colorId) {
            setTool('pen'); 
            currentColor = colorId;
            refreshColorSelection();
        }

        function refreshColorSelection() {
            document.querySelectorAll('.color-tile, .saved-tile').forEach(el => {
                el.classList.remove('selected');
                if (el.dataset.color === currentColor || el.dataset.id == currentColor) {
                    el.classList.add('selected');
                }
            });
        }

        document.getElementById('saveColor').addEventListener('click', () => {
            if (savedColorsMap.size >= MAX_COLORS) {
                alert(`ÊúÄÂ§ß${MAX_COLORS}ÂÄã„Åæ„Åß„Åß„Åô„ÄÇ`);
                return;
            }
            const r = document.getElementById('red').value;
            const g = document.getElementById('green').value;
            const b = document.getElementById('blue').value;
            const col = `rgb(${r},${g},${b})`;
            
            const id = customColorIndex++;
            savedColorsMap.set(id, col);
            renderSavedColors();
            updateColorCount();
        });

        function renderSavedColors() {
            savedColorsDiv.innerHTML = '';
            const ids = Array.from(savedColorsMap.keys());
            for(let i=0; i<MAX_COLORS; i++) {
                const item = document.createElement('div');
                item.className = 'saved-item';
                if(i < ids.length) {
                    const id = ids[i];
                    const color = savedColorsMap.get(id);
                    const tile = document.createElement('div');
                    tile.className = 'saved-tile';
                    tile.dataset.id = id;
                    tile.style.backgroundColor = color;
                    if (currentColor === id && !isErasing && !isPicking) tile.classList.add('selected');
                    tile.onclick = () => selectColor(id);
                    
                    const del = document.createElement('div');
                    del.className = 'del-btn';
                    del.innerText = '√ó';
                    del.onclick = (e) => { e.stopPropagation(); deleteColor(id); };
                    
                    item.appendChild(tile);
                    item.appendChild(del);
                }
                savedColorsDiv.appendChild(item);
            }
        }

        function deleteColor(id) {
            saveState();
            savedColorsMap.delete(id);
            if (currentColor === id) {
                currentColor = 'black';
                refreshColorSelection();
            }
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (pixelData[i][j] === id) pixelData[i][j] = 0;
                }
            }
            renderSavedColors();
            updateColorCount();
            draw();
        }

        function updateColorCount() {
            colorCountSpan.innerText = `${savedColorsMap.size} / ${MAX_COLORS}`;
        }

        document.getElementById('download').addEventListener('click', async () => {
            const outSize = parseInt(document.getElementById('imageSize').value);
            const format = document.getElementById('formatSelect').value;
            const outCanvas = document.createElement('canvas');
            outCanvas.width = outSize; outCanvas.height = outSize;
            const oCtx = outCanvas.getContext('2d');
            oCtx.imageSmoothingEnabled = false;
            const unit = outSize / gridSize;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const val = pixelData[i][j];
                    if(val !== 0) {
                        oCtx.fillStyle = getActualColor(val);
                        oCtx.fillRect(i * unit, j * unit, Math.ceil(unit), Math.ceil(unit));
                    }
                }
            }
            const link = document.createElement('a');
            link.download = document.getElementById('filename').value + "." + format;
            if (format === 'ico') {
                outCanvas.toBlob(async (blob) => {
                    const buf = await blob.arrayBuffer();
                    const view = new DataView(new ArrayBuffer(22 + buf.byteLength));
                    view.setUint16(2, 1, true); view.setUint16(4, 1, true);
                    view.setUint8(6, outSize >= 256 ? 0 : outSize);
                    view.setUint8(7, outSize >= 256 ? 0 : outSize);
                    view.setUint16(12, 32, true); view.setUint32(14, buf.byteLength, true);
                    view.setUint32(18, 22, true);
                    const final = new Uint8Array(view.buffer);
                    final.set(new Uint8Array(buf), 22);
                    link.href = URL.createObjectURL(new Blob([final], {type: 'image/x-icon'}));
                    link.click();
                }, 'image/png');
            } else {
                link.href = outCanvas.toDataURL(`image/${format === 'bmp' ? 'bmp' : 'png'}`);
                link.click();
            }
        });

        init();
    </script>
</body>
</html>
